<!DOCTYPE html>
<html lang="en">
<head>
    <script>
    (function(firebaseConfig, initialAuthToken, appId) {
        window.__firebase_config = firebaseConfig;
        window.__initial_auth_token = initialAuthToken;
        window.__app_id = appId;
    })("\n{\n  \"apiKey\": \"AIzaSyCqyCcs2R2e7AegGjvFAwG98wlamtbHvZY\",\n  \"authDomain\": \"bard-frontend.firebaseapp.com\",\n  \"projectId\": \"bard-frontend\",\n  \"storageBucket\": \"bard-frontend.firebasestorage.app\",\n  \"messagingSenderId\": \"175205271074\",\n  \"appId\": \"1:175205271074:web:2b7bd4d34d33bf38e6ec7b\"\n}\n", "eyJhbGciOiJSUzI1NiIsImtpZCI6IjM3MTE1MjViZGZmNmM4YmM2NjM2NDE3ZjgwOGMzYzFlYTkyN2E0YmMiLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BiYXJkLWZyb250ZW5kLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwiYXVkIjoiaHR0cHM6XC9cL2lkZW50aXR5dG9vbGtpdC5nb29nbGVhcGlzLmNvbVwvZ29vZ2xlLmlkZW50aXR5LmlkZW50aXR5dG9vbGtpdC52MS5JZGVudGl0eVRvb2xraXQiLCJ1aWQiOiIxMjI1NjQ1NDAzMDYxNzk1NjMzNiIsImlzcyI6ImZpcmViYXNlLWFkbWluc2RrLWZic3ZjQGJhcmQtZnJvbnRlbmQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJjbGFpbXMiOnsiYXBwSWQiOiJjX2Y1MzYwNDBmYTU2ZDZjZmNfcmV2aWV3LXdpZGdldC1nZW5lcmF0b3ItODc3In0sImV4cCI6MTc1MTkyNTU4MywiaWF0IjoxNzUxOTIxOTgzLCJhbGciOiJSUzI1NiJ9.u-1a0jLFOUAsbjmSpzsHEF5a1pWtq-u17lOI-iyHuGy67u3BfmG1m8aHE36TRqm3RH_bPB-stuMbV8oVcMtmjmS5hj5XZaMuywG7qQiyyIkok7pbHwafgQatY5cItw3SEV-1HkePG9_AZWKFWP_HmzfqQt6pEq_95SMjA5xV91iQAIWKShwSIjWhvHzbdMKzTb2GP_7cdPGqwVMLjIyr46tirnjBTzRkIgAv49_-I6l6Dl5HxNuLbFi1KOlV2QlNmFZrvFBngcL9wLMQXQF6vlED6FiTD8xdZlVDfy1UlpWQF1dW2YkFcWqnCfCvdrz_6-KpWDzTO-tZ0wXlTSmt3Q", "c_f536040fa56d6cfc_review-widget-generator-877")
    </script>
    <script>
    (function() {
        // Ensure this script is executed only once
        if (window.firebaseAuthBridgeScriptLoaded) {
            return;
        }
        window.firebaseAuthBridgeScriptLoaded = true;

        let nextTokenPromiseId = 0;

        // Stores { resolve, reject } for ongoing token requests
        const pendingTokenPromises = {};

        // Listen for messages from the Host Application
        window.addEventListener('message', function(event) {

            const messageData = event.data;

            if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
                const {success, token, error, promiseId} = messageData ?? {};
                if (pendingTokenPromises[promiseId]) {
                    if (success) {
                        pendingTokenPromises[promiseId].resolve(token);
                    } else {
                        pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
                    }
                    delete pendingTokenPromises[promiseId];
                }
            }
        });

        // Expose a function for the Generated App to request a new Firebase token
        window.requestNewFirebaseToken = function() {
            const currentPromiseId = nextTokenPromiseId++;
            const promise = new Promise((resolve, reject) => {
                pendingTokenPromises[currentPromiseId] = {
                    resolve,
                    reject
                };
            });
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    type: 'REQUEST_NEW_FIREBASE_TOKEN',
                    promiseId: currentPromiseId
                }, '*');
            } else {
                pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
                delete pendingTokenPromises[currentPromiseId];
            }
            return promise;
        };
    })();
    </script>
    <script>
    let realOriginalGetUserMedia = null;
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    }

    (function() {
        if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
            try {
                Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
                    get: function() {
                        return undefined; // Or throw an error
                    },
                    configurable: false
                });
            } catch (error) {
                console.error("Error defining prototype getter:", error);
            }
        }
    })();

    (function() {
        const pendingMediaResolvers = {};
        let nextMediaPromiseId = 0;

        function requestMediaPermissions(constraints) {
            const mediaPromiseId = nextMediaPromiseId++;
            const promise = new Promise((resolve, reject) => {
                pendingMediaResolvers[mediaPromiseId] = (granted) => {
                    delete pendingMediaResolvers[mediaPromiseId];
                    resolve(granted);
                };
            });

            window.parent.postMessage({
                type: 'requestMediaPermission',
                constraints: constraints,
                promiseId: mediaPromiseId,
            }, '*');

            return promise;
        }

        let originalGetUserMedia = realOriginalGetUserMedia;

        function interceptGetUserMedia() {
            if (navigator.mediaDevices) {
                Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
                    value: function(constraints) {
                        return requestMediaPermissions(constraints).then((granted) => {
                            if (granted) {
                                if (originalGetUserMedia) {
                                    return originalGetUserMedia(constraints);
                                } else {
                                    throw new Error("Original getUserMedia not available.");
                                }
                            } else {
                                throw new DOMException('Permission denied', 'NotAllowedError');
                            }
                        });
                    },
                    writable: false,
                    configurable: false
                });
            }
        }

        interceptGetUserMedia();

        const observer = new MutationObserver(function(mutationsList, observer) {
            for (const mutation of mutationsList) {
                if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
                    interceptGetUserMedia();
                } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
                    interceptGetUserMedia();
                } else if (mutation.type === 'childList' && mutation.addedNodes) {
                    mutation.addedNodes.forEach(node => {
                        if (node === navigator.mediaDevices) {
                            interceptGetUserMedia();
                        }
                    });
                }
            }
        });

        function interceptSpeechRecognition() {
            if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
                return;
            }

            const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            const SpeechRecognitionWrapper = function(...args) {
                const recognizer = new OriginalSpeechRecognition(...args);
                const originalStart = recognizer.start.bind(recognizer);

                recognizer.start = function() {
                    requestMediaPermissions({
                        audio: true
                    }).then(granted => {
                        if (granted) {
                            originalStart();
                        } else {
                            const errorEvent = new SpeechRecognitionErrorEvent('error');
                            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
                            recognizer.dispatchEvent(errorEvent);
                        }
                    });
                };

                return recognizer;
            };

            SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
            SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

            if (window.SpeechRecognition) {
                window.SpeechRecognition = SpeechRecognitionWrapper;
            }
            if (window.webkitSpeechRecognition) {
                window.webkitSpeechRecognition = SpeechRecognitionWrapper;
            }
        }

        interceptSpeechRecognition();

        window.addEventListener('message', function(event) {
            if (event.data) {
                if (event.data.type === 'resolveMediaPermission') {
                    const {promiseId, granted} = event.data;
                    if (pendingMediaResolvers[promiseId]) {
                        pendingMediaResolvers[promiseId](granted);
                    }
                }
            }
        });

    })();
    </script>
    <script>
    ((function(modelInformation) {
        const originalFetch = window.fetch;
        // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
        let googleLlmBaseApiUrls = [
        'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
        'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
        'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
        'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
        'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
        'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
        'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
        ];
        modelInformation.deprecatedTextModelNames.forEach((modelName) => {
            googleLlmBaseApiUrls.push(
            'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
            'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
            );
        });

        const pendingFetchResolvers = {};
        let nextPromiseId = 0;

        function handleStringInput(input, optionsArgument) {
            const actualUrl = input;
            const fetchCallArgs = [actualUrl, optionsArgument];
            const effectiveOptions = optionsArgument || {};
            const bodyForApiKeyCheck = effectiveOptions.body;
            const bodyForPostMessage = effectiveOptions.body;
            return {
                actualUrl,
                fetchCallArgs,
                effectiveOptions,
                bodyForApiKeyCheck,
                bodyForPostMessage
            };
        }

        function handleRequestInput(input, optionsArgument) {
            const actualUrl = input.url;
            const fetchCallArgs = [input, optionsArgument];
            const effectiveOptions = {
                method: input.method,
                headers: new Headers(input.headers)
            };
            let bodyForApiKeyCheck;
            let bodyForPostMessage;

            if (optionsArgument) {
                if (optionsArgument.method)
                    effectiveOptions.method = optionsArgument.method;
                if (optionsArgument.headers)
                    effectiveOptions.headers = new Headers(optionsArgument.headers);
                if ('body' in optionsArgument) {
                    bodyForApiKeyCheck = optionsArgument.body;
                    bodyForPostMessage = optionsArgument.body;
                } else {
                    bodyForApiKeyCheck = undefined;
                    bodyForPostMessage = input.body;
                }
            } else {
                bodyForApiKeyCheck = undefined;
                bodyForPostMessage = input.body;
            }
            return {
                actualUrl,
                fetchCallArgs,
                effectiveOptions,
                bodyForApiKeyCheck,
                bodyForPostMessage
            };
        }

        window.fetch = function(input, optionsArgument) {
            let actualUrl;
            let fetchCallArgs;
            let effectiveOptions = {};
            let bodyForApiKeyCheck;
            let bodyForPostMessage;

            if (typeof input === 'string') {
                ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
            } else if (input instanceof Request) {
                ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
            } else {
                return originalFetch.apply(window, [input, optionsArgument]);
            }

            effectiveOptions.method = effectiveOptions.method || 'GET';
            if (!effectiveOptions.headers) {
                effectiveOptions.headers = new Headers();
            }


            if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
                let apiKeyIsNull = true;

                const regex = new RegExp("models/([^:]+)");
                const modelNameMatch = actualUrl.match(regex);
                const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


                try {
                    const urlObject = new URL(actualUrl); // Use URL object for robust parsing
                    const apiKeyParam = urlObject.searchParams.get('key');
                    if (apiKeyParam) {
                        apiKeyIsNull = false;
                    }
                } catch (e) {

                }

                if (apiKeyIsNull && effectiveOptions.headers) {
                    const h = new Headers(effectiveOptions.headers);
                    const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
                    if (apiKeyHeaderValue) {
                        apiKeyIsNull = false;
                        return originalFetch.apply(window, fetchCallArgs);
                    }
                }

                if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
                    try {
                        const bodyData = JSON.parse(bodyForApiKeyCheck);
                        if (bodyData && bodyData.apiKey) {
                            apiKeyIsNull = false;
                            return originalFetch.apply(window, fetchCallArgs);
                        }
                    } catch (e) {

                    }
                }

                if (apiKeyIsNull) {
                    const promiseId = nextPromiseId++;
                    const promise = new Promise((resolve) => {
                        pendingFetchResolvers[promiseId] = (resolvedResponse) => {
                            delete pendingFetchResolvers[promiseId];
                            resolve(resolvedResponse);
                        };
                    });

                    let serializedBodyForPostMessage;
                    if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
                        serializedBodyForPostMessage = bodyForPostMessage;
                    } else if (bodyForPostMessage instanceof ReadableStream) {
                        serializedBodyForPostMessage = null;
                    } else {
                        try {
                            serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
                        } catch (e) {
                            serializedBodyForPostMessage = null;
                        }
                    }

                    const messageOptions = {
                        method: effectiveOptions.method,
                        headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
                        body: serializedBodyForPostMessage
                    };

                    window.parent.postMessage({
                        type: 'requestFetch',
                        url: actualUrl,
                        modelName: modelName,
                        options: messageOptions,
                        promiseId: promiseId,
                    }, '*');

                    return promise;
                }
                return originalFetch.apply(window, fetchCallArgs);
            }
            return originalFetch.apply(window, fetchCallArgs);
        };

        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'resolveFetch') {
                const {promiseId, response} = event.data;
                if (pendingFetchResolvers[promiseId]) {
                    try {
                        const reconstructedResponse = new Response(response.body, {
                            status: response.status,
                            statusText: response.statusText,
                            headers: new Headers(response.headers),
                        });
                        pendingFetchResolvers[promiseId](reconstructedResponse);
                    } catch (error) {
                        pendingFetchResolvers[promiseId](new Response(null, {
                            status: 500,
                            statusText: "Interceptor Response Reconstruction Error"
                        }));
                    }
                }
            }
        });

    }))({
        "textModelName": "gemini-2.5-flash-preview-04-17",
        "imageModelName": "imagen-3.0-generate-002",
        "imageEditModelName": "gemini-2.0-flash-preview-image-generation",
        "videoModelName": "veo-2.0-generate-001",
        "deprecatedTextModelNames": ["gemini-2.0-flash"]
    })
    </script>
    <script>
    (function() {
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;

        /**
           * Normalizes an error event or a promise rejection reason into a structured error object.
           * @param {*} errorEventOrReason The error object or reason.
           * @return {object} Structured error data { message, name, stack }.
           */
        function getErrorObject(errorEventOrReason) {
            if (errorEventOrReason instanceof Error) {
                return {
                    message: errorEventOrReason.message,
                    name: errorEventOrReason.name,
                    stack: errorEventOrReason.stack,
                };
            }
            // Fallback for non-Error objects.
            try {
                return {
                    message: JSON.stringify(errorEventOrReason),
                    name: 'UnknownErrorType',
                    stack: null,
                };
            } catch (e) {
                return {
                    message: String(errorEventOrReason),
                    name: 'UnknownErrorTypeNonStringifiable',
                    stack: null,
                };
            }
        }

        /**
           * Converts an array of arguments (from log/error) into a single string.
           * Handles Error objects specially to include their message and stack.
           * @param {Array<*>} args - Arguments passed to console methods.
           * @return {string} A string representation of the arguments.
           */
        function stringifyArgs(args) {
            return args
            .map((arg) => {
                if (arg instanceof Error) {
                    const {message, stack} = arg;
                    return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
                }
                if (typeof arg === 'object' && arg !== null) {
                    try {
                        return JSON.stringify(arg);
                    } catch (error) {
                        return '[Circular Object]';
                    }
                } else {
                    return String(arg);
                }
            })
            .join(' ');
        }

        console.log = function(...args) {
            const logString = stringifyArgs(args);
            window.parent.postMessage({
                type: 'log',
                message: logString
            }, '*');
            originalConsoleLog.apply(console, args);
        };

        console.error = function(...args) {
            let errorData;
            if (args.length > 0 && args[0] instanceof Error) {
                const err = args[0];
                // If the first arg is an Error, capture its details.
                errorData = {
                    type: 'error',
                    source: 'CONSOLE_ERROR',
                    ...getErrorObject(err),
                    rawArgsString: stringifyArgs(args.slice(1)),
                    timestamp: new Date().toISOString(),
                };
            } else {
                // If not an Error object, treat all args as a general error message.
                errorData = {
                    type: 'error',
                    source: 'CONSOLE_ERROR',
                    message: stringifyArgs(args),
                    name: 'ConsoleLoggedError',
                    stack: null,
                    timestamp: new Date().toISOString(),
                };
            }
            window.parent.postMessage(errorData, '*');
            originalConsoleError.apply(console, args);
        };

        // Listen for global unhandled synchronous errors.
        window.addEventListener('error', function(event) {
            const errorDetails = event.error ? getErrorObject(event.error) : {
                message: event.message,
                name: 'GlobalError',
                stack: null,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
            };

            window.parent.postMessage({
                type: 'error',
                source: 'global',
                ...errorDetails,
                message: errorDetails.message || event.message,
                timestamp: new Date().toISOString(),
            }, '*');
        });

        // Listen for unhandled promise rejections (asynchronous errors).
        window.addEventListener('unhandledrejection', function(event) {
            const errorDetails = getErrorObject(event.reason);

            window.parent.postMessage({
                type: 'error',
                source: 'unhandledrejection',
                ...errorDetails,
                message: errorDetails.message || 'Unhandled Promise Rejection',
                timestamp: new Date().toISOString(),
            }, '*');
        });

    })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Proof Widget Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Inter', sans-serif;
    }

    .avatar-shadow {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }/* Simple transition for a smoother feel */

    .transition-all {
        transition: all 0.3s ease-in-out;
    }/* Spinner animation */

    .animate-spin {
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div class="container mx-auto p-4 md:p-8">

        <!-- Header -->
        <header class="text-center mb-8 md:mb-12">
            <h1 class="text-3xl md:text-5xl font-bold text-slate-900">Social Proof Widget Generator</h1>
            <p class="mt-3 text-lg text-slate-600 max-w-2xl mx-auto">Customize your own social proof widget with overlapping avatars and star ratings to build trust.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-2 gap-8">

            <!-- Left Column: Input Form -->
            <div class="bg-white p-6 md:p-8 rounded-2xl shadow-lg">
                <h2 class="text-2xl font-bold mb-6 text-slate-900">1. Customize Your Widget</h2>

                <div class="space-y-6">
                    <!-- Avatar Images Uploader -->
                    <div>
                        <label class="block text-sm font-medium text-slate-700 mb-3">Upload Avatar Images</label>
                        <div class="space-y-4">
                            <!-- Avatar 1 Upload -->
                            <div class="flex items-center space-x-4">
                                <img id="avatarPreview1" src="https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=facearea&amp;facepad=2&amp;w=256&amp;h=256&amp;q=80" class="w-14 h-14 rounded-full object-cover ring-2 ring-slate-200 border-2 border-slate-100">
                                <label for="avatarUpload1" class="upload-label cursor-pointer bg-white border border-slate-300 rounded-md shadow-sm px-3 py-2 text-sm font-medium text-slate-700 hover:bg-slate-50 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
                                    <svg class="spinner hidden w-5 h-5 mr-2 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    <span class="upload-text">Upload Image 1</span>
                                    <input id="avatarUpload1" type="file" class="sr-only" accept="image/*">
                                </label>
                            </div>
                            <!-- Avatar 2 Upload -->
                            <div class="flex items-center space-x-4">
                                <img id="avatarPreview2" src="https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&amp;auto=format&amp;fit=facearea&amp;facepad=2&amp;w=256&amp;h=256&amp;q=80" class="w-14 h-14 rounded-full object-cover ring-2 ring-slate-200 border-2 border-slate-100">
                                <label for="avatarUpload2" class="upload-label cursor-pointer bg-white border border-slate-300 rounded-md shadow-sm px-3 py-2 text-sm font-medium text-slate-700 hover:bg-slate-50 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
                                    <svg class="spinner hidden w-5 h-5 mr-2 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    <span class="upload-text">Upload Image 2</span>
                                    <input id="avatarUpload2" type="file" class="sr-only" accept="image/*">
                                </label>
                            </div>
                            <!-- Avatar 3 Upload -->
                            <div class="flex items-center space-x-4">
                                <img id="avatarPreview3" src="https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=facearea&amp;facepad=2&amp;w=256&amp;h=256&amp;q=80" class="w-14 h-14 rounded-full object-cover ring-2 ring-slate-200 border-2 border-slate-100">
                                <label for="avatarUpload3" class="upload-label cursor-pointer bg-white border border-slate-300 rounded-md shadow-sm px-3 py-2 text-sm font-medium text-slate-700 hover:bg-slate-50 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
                                    <svg class="spinner hidden w-5 h-5 mr-2 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    <span class="upload-text">Upload Image 3</span>
                                    <input id="avatarUpload3" type="file" class="sr-only" accept="image/*">
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Review Count -->
                    <div>
                        <label for="reviewCount" class="block text-sm font-medium text-slate-700 mb-1">Review Count Text</label>
                        <input type="text" id="reviewCount" value="100+" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-all" placeholder="e.g., 100+ or 5k+">
                    </div>

                    <!-- Star Rating -->
                    <div>
                        <label class="block text-sm font-medium text-slate-700 mb-2">Star Rating</label>
                        <div id="starRating" class="flex items-center space-x-2 text-3xl text-slate-300">
                            <svg data-value="1" class="w-8 h-8 cursor-pointer star" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                            </svg>
                            <svg data-value="2" class="w-8 h-8 cursor-pointer star" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                            </svg>
                            <svg data-value="3" class="w-8 h-8 cursor-pointer star" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                            </svg>
                            <svg data-value="4" class="w-8 h-8 cursor-pointer star" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                            </svg>
                            <svg data-value="5" class="w-8 h-8 cursor-pointer star" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path>
                            </svg>
                        </div>
                    </div>

                    <!-- Text Content -->
                    <div>
                        <label for="mainHeading" class="block text-sm font-medium text-slate-700 mb-1">Main Heading</label>
                        <input type="text" id="mainHeading" value="5-Star Reviews" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-all">
                    </div>
                    <div>
                        <label for="subheading" class="block text-sm font-medium text-slate-700 mb-1">Subheading</label>
                        <input type="text" id="subheading" value="Join our community of happy customers." class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition-all">
                    </div>

                </div>
            </div>

            <!-- Right Column: Preview and Code -->
            <div class="space-y-8">
                <!-- Preview Section -->
                <div class="bg-white p-6 md:p-8 rounded-2xl shadow-lg">
                    <h2 class="text-2xl font-bold mb-6 text-slate-900">2. Live Preview</h2>
                    <div id="preview" class="bg-slate-100 p-6 rounded-lg flex items-center justify-center min-h-[250px]">
                        <!-- Generated widget will be injected here -->
                    </div>
                </div>

                <!-- Code Section -->
                <div class="bg-slate-900 p-6 md:p-8 rounded-2xl shadow-lg">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold text-white">3. Copy Your Code</h2>
                        <button id="copyButton" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900 focus:ring-indigo-500 transition-all">
                                                    Copy Code
                                                </button>
                    </div>
                    <div class="relative">
                        <pre class="bg-slate-800 text-slate-300 p-4 rounded-lg overflow-x-auto text-sm">
                            <code id="codeOutput" class="language-html"></code>
                        </pre>
                        <div id="copySuccess" class="absolute top-2 right-2 bg-green-500 text-white text-xs font-bold px-2 py-1 rounded-md opacity-0 transition-opacity duration-300">Copied!</div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // --- DOM Elements ---
        const inputs = {
            reviewCount: document.getElementById('reviewCount'),
            mainHeading: document.getElementById('mainHeading'),
            subheading: document.getElementById('subheading'),
        };
        const starRatingContainer = document.getElementById('starRating');
        const stars = starRatingContainer.querySelectorAll('.star');
        const previewContainer = document.getElementById('preview');
        const codeOutput = document.getElementById('codeOutput');
        const copyButton = document.getElementById('copyButton');
        const copySuccessMessage = document.getElementById('copySuccess');

        // --- State ---
        let currentRating = 5;
        const avatarData = {
            avatar1: 'https://images.unsplash.com/photo-1491528323818-fdd1faba62cc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80',
            avatar2: 'https://images.unsplash.com/photo-1550525811-e5869dd03032?ixlib=rb-1.2.1&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80',
            avatar3: 'https://images.unsplash.com/photo-1500648767791-00dcc994a43e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80',
        };

        // --- SVG for Stars ---
        const starSVG = `<svg class="w-6 h-6 text-yellow-400" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/></svg>`;

        // --- Functions ---

        function updateStarsUI() {
            stars.forEach(star => {
                const starValue = parseInt(star.dataset.value);
                star.classList.toggle('text-yellow-400', starValue <= currentRating);
                star.classList.toggle('text-slate-300', starValue > currentRating);
            });
        }

        function generateStarHTML(rating) {
            let html = '';
            for (let i = 0; i < rating; i++) {
                html += starSVG;
            }
            return html;
        }

        function sanitize(str) {
            const temp = document.createElement('div');
            temp.textContent = str;
            return temp.innerHTML;
        }

        /**
                     * Handles file upload, reads the file as a Data URL, and updates the state.
                     * @param {Event} event - The file input change event.
                     * @param {string} avatarKey - The key in avatarData to update (e.g., 'avatar1').
                     */
        function handleFileUpload(event, avatarKey) {
            const fileInput = event.target;
            const label = fileInput.closest('label');
            const textSpan = label.querySelector('.upload-text');
            const spinner = label.querySelector('.spinner');

            const file = fileInput.files[0];
            if (!file)
                return;

            // Show loading state
            textSpan.textContent = 'Uploading...';
            spinner.classList.remove('hidden');
            fileInput.setAttribute('disabled', true);
            label.classList.add('opacity-50', 'cursor-not-allowed');

            const reader = new FileReader();
            reader.onload = (e) => {
                const base64String = e.target.result;
                avatarData[avatarKey] = base64String;
                document.getElementById(`avatarPreview${avatarKey.slice(-1)}`).src = base64String;

                // Hide loading state
                textSpan.textContent = `Upload Image ${avatarKey.slice(-1)}`;
                spinner.classList.add('hidden');
                fileInput.removeAttribute('disabled');
                label.classList.remove('opacity-50', 'cursor-not-allowed');

                generate(); // Regenerate the widget with the new image
            };
            reader.readAsDataURL(file);
        }

        function generate() {
            const values = {
                reviewCount: sanitize(inputs.reviewCount.value),
                mainHeading: sanitize(inputs.mainHeading.value),
                subheading: sanitize(inputs.subheading.value),
            };

            const starHTML = generateStarHTML(currentRating);

            const widgetHTML = `
<!-- Social Proof Widget Start -->
<!-- Note: The long 'src' strings for images are Base64-encoded data, which makes this widget self-contained. -->
<div class="max-w-sm mx-auto bg-white p-6 rounded-2xl shadow-lg">
    <div class="flex flex-col items-center text-center">
        
        <div class="flex items-center justify-center -space-x-2 mb-4">
            <img class="relative z-30 inline-block h-14 w-14 rounded-full object-cover ring-4 ring-white border-2 border-slate-100" style="box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);" 
                 src="${






            avatarData.avatar1}" 
                 alt="Reviewer 1">
            <img class="relative z-20 inline-block h-14 w-14 rounded-full object-cover ring-4 ring-white border-2 border-slate-100" style="box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);" 
                 src="${

            avatarData.avatar2}" 
                 alt="Reviewer 2">
            <img class="relative z-10 inline-block h-14 w-14 rounded-full object-cover ring-4 ring-white border-2 border-slate-100" style="box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);" 
                 src="${

            avatarData.avatar3}" 
                 alt="Reviewer 3">
            <div class="relative z-0 flex items-center justify-center h-14 w-14 rounded-full bg-indigo-600 text-white text-xs font-bold ring-4 ring-white" style="box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);">
                ${

            values.reviewCount}
            </div>
        </div>

        <div class="flex items-center mb-2">
            ${



            starHTML.replace(/\s\s+/g, ' ')}
        </div>

        <h3 class="text-xl font-bold text-slate-800 mt-2">${

            values.mainHeading}</h3>
        <p class="text-slate-500 text-sm mt-1">${values.subheading}</p>

    </div>
</div>
<!-- Social Proof Widget End -->
                `




            .trim();

            previewContainer.innerHTML = widgetHTML;
            codeOutput.textContent = widgetHTML;
        }

        // --- Event Listeners ---

        Object.values(inputs).forEach(el => el.addEventListener('input', generate));
        starRatingContainer.addEventListener('click', (e) => {
            const star = e.target.closest('.star');
            if (star) {
                currentRating = parseInt(star.dataset.value);
                updateStarsUI();
                generate();
            }
        });

        // Set up file upload listeners
        document.getElementById('avatarUpload1').addEventListener('change', (e) => handleFileUpload(e, 'avatar1'));
        document.getElementById('avatarUpload2').addEventListener('change', (e) => handleFileUpload(e, 'avatar2'));
        document.getElementById('avatarUpload3').addEventListener('change', (e) => handleFileUpload(e, 'avatar3'));

        copyButton.addEventListener('click', () => {
            const textToCopy = codeOutput.textContent;
            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = textToCopy;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            try {
                document.execCommand('copy');
                copySuccessMessage.style.opacity = '1';
                setTimeout(() => {
                    copySuccessMessage.style.opacity = '0';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
            document.body.removeChild(tempTextarea);
        });

        // --- Initial Load ---
        updateStarsUI();
        generate();
    });
    </script>

</body>
</html>
